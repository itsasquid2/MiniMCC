variables:
	{mcc.bingonew.timeleft} = 0
	{mcc.bingonew.stage} = 0
	{mcc.bingonew.portalcooldown.%player%} = false

function mccbingonewtutorial(p:player):
	wait 3 seconds
	send title "<yellow>Bingo" to {_p} for 5 seconds
	wait 5 seconds
	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "<yellow>Welcome to Bingo!" to {_p}
	send "" to {_p}
	send "<italics>Here's how you play..." to {_p}
	send "" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}

	wait 3 seconds

	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "<bold>Bingo is a Minecraft scavenger hunt!" to {_p}
	send "" to {_p}
	send "Your goal is to collect the items shown on your <gold>Bingo Card<white> before other teams do!" to {_p}
	send "" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}

	wait 5 seconds

	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "<bold>You earn coins for each item found, but other teams are also finding the same items. It's a race to see who can find it first!" to {_p}
	send "" to {_p}
	send "To score an item, simply pick up the item. <red>Picking it up from a chest or a crafting table does not work, you NEED to pick it up from the ground" to {_p}
	send "" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}

	wait 8 seconds

	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "<bold>One member of your team may teleport to another once every 3 minutes!" to {_p}
	send "" to {_p}
	send "Use this ability wisely! Teleport using /teamtp [teammate]." to {_p}
	send "" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}

	wait 8 seconds

	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "<bold>Use the portals in the warehouse to get wherever you need to go!" to {_p}
	send "" to {_p}
	send "Most portals take you to a biome, but there are exceptions." to {_p}
	send "" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}

	wait 6 seconds

	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "Note: Other teams completing goals will make them uncompletable, but a new goal will appear after a few seconds." to {_p}
	send "" to {_p}
	send "this is similar to lockout bingo. (you also can't actually score bingos)" to {_p}
	send "" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}

	wait 6 seconds	

	send "<lime>--------------------------------------------------" to {_p}
	send "" to {_p}
	send "<bold>Hope you enjoy this MMCC original! (Note: KeepInventory is on!)" to {_p}
	send "" to {_p}
	send "Good luck!" to {_p}
	send "" to {_p}
	send "<lime>--------------------------------------------------" to {_p}


command /mccbingonew:
	permission: op
	trigger:
		if command sender is not the console:
			if command sender is not "itsasquid2":
				if {mmcc.hosts::*} doesn't contain command sender:
					message "<pink>You cannot do this!"
					exit trigger
		if {mcc.bingo.inprogress} is true:
			message "Bingo already in progress!"
			exit trigger
		execute console command "/mccnewgame"
		set {mcc.bingo.inprogress} to true
		set {mcc.currentevent} to "bingonew"
		set {bingo.tictactoe} to false
		loop all players:
			if {mcc.team.%loop-player%} is not equal to 0:
				execute console command "/mvtp %loop-player% bingo"
				if "%loop-player's world%" is equal to "bingo":
					set {immune.%loop-player%} to false
					set {mcc.bingonew.portalcooldown.%loop-player%} to false
					wait a tick
					set loop-player's game mode to adventure
					feed loop-player
					heal loop-player
					clear the loop-player's inventory
					clear the loop-player's potion effects
					execute console command "/effect give %loop-player% night_vision infinite"
					set {bingo.itemsfound.%loop-player%} to 0
					set loop-player's chestplate to unbreakable elytra named "<gold>Bingo Elytra"
					set slot 8 of loop-player's inventory to paper of curse of vanishing named "<gold>Bingo Card"
					give ender pearl of curse of vanishing named "<gold>Teleport to spawn" to loop-player
					mccbingonewtutorial(loop-player)
		loop 10 times:
			set {mcc.bingo.tpcooldown.%loop-number%} to 0
		set {mcc.bingonew.stage} to 0
		set {mcc.bingonew.timeleft} to 90
		generatebingoobjectives()
		delete {mcc.bingo.items::*}

on drop:
	"%world%" starts with "bingo"
	event-item is ender pearl of curse of vanishing named "<gold>Teleport to spawn"
	cancel event

command /givecard <player>:
	permission: op
	trigger:
		give arg paper of curse of vanishing named "<gold>Bingo Card"

function bingoscoreobjective(player:player, item:item, diff:text):
	remove 1 of {_item} from {mcc.bingo.%{_diff}%objs::*}
	set {_pane} to glass pane named formatted "<light cyan>Completed by <%mcccolor({mcc.team.%{_player}'s name%})%>%{_player}'s name%" 
	set color of {_pane} to mcccolor({mcc.team.%{_player}'s name%})
	add {_pane} to {mcc.bingo.%{_diff}%objs::*} 
	if {_diff} is "med":
		set {_diff} to "medium"
	if name of {_item} is set:
		broadcast formatted "<%mcccolor({mcc.team.%{_player}'s name%})%>%{_player}'s name% <light cyan>completed a %{_diff}% %name of {_item}%"
	else:
		broadcast formatted "<%mcccolor({mcc.team.%{_player}'s name%})%>%{_player}'s name% <light cyan>completed a %{_diff}% Task: pick up %{_item}%"
	if {_diff} is "hard":
		ac({_player}, 250, "Completed a %{_diff}% task!", false)
	else if {_diff} is "medium":
		ac({_player}, 150, "Completed a %{_diff}% task!", false)
	else if {_diff} is "easy":
		ac({_player}, 25, "Completed a %{_diff}% task!", false)
	if {_diff} is "medium":
		set {_diff} to "med"
	wait 1 tick
	loop {mcc.bingo.%{_diff}%objs::*}:
		set slot (20+loop-counter) of {mcc.bingo.board} to loop-value
	wait 4 seconds
	generatebingoobjective({_diff})
	loop {mcc.bingo.%{_diff}%objs::*}:
		set slot (20+loop-counter) of {mcc.bingo.board} to loop-value
	add 1 to {bingo.itemsfound.%{_diff}%.%{_player}%}

on rightclick:
	"%player's world%" starts with "bingo"
	if player's tool is paper of curse of vanishing named "<gold>Bingo Card":
		openbingocard(player)
	if player's tool is ender pearl of curse of vanishing named "<gold>Teleport to spawn":
		cancel event
		execute console command "/mvtp %player% bingo"
		wait 1 tick
		give player player's chestplate
		set player's chestplate to unbreakable elytra named "<gold>Bingo Elytra"
		set player's gamemode to adventure
		if player doesn't have ender pearl of curse of vanishing named "<gold>Teleport to spawn":
			give player ender pearl of curse of vanishing named "<gold>Teleport to spawn"

function openbingocard(p:player):
	if {mcc.bingo.board} is not set:
		open chest inventory with 3 rows to {_p}
		set {mcc.bingo.board} to {_p}'s current inventory
	else:
		open {mcc.bingo.board} to {_p}
	clear {_p}'s current inventory
	set slot 2 of {mcc.bingo.board} to green concrete named "<lime>Easy Tasks"
	set slot 11 of {mcc.bingo.board} to yellow concrete named "<yellow>Medium Tasks"
	set slot 20 of {mcc.bingo.board} to red concrete named "<red>Hard Tasks"
	loop {mcc.bingo.easyobjs::*}:
		set slot (2+loop-counter) of {mcc.bingo.board} to loop-value
	loop {mcc.bingo.medobjs::*}:
		set slot (11+loop-counter) of {mcc.bingo.board} to loop-value
	loop {mcc.bingo.hardobjs::*}:
		set slot (20+loop-counter) of {mcc.bingo.board} to loop-value

on smelting start:
	"%event-world%" starts with "bingo"
	set total cook time to 1 tick

function generatebingoobjectives():
	set {mcc.bingo.easyobjectives.temp::*} to {mcc.bingo.easyobjectives::*}
	set {mcc.bingo.medobjectives.temp::*} to {mcc.bingo.medobjectives::*}
	set {mcc.bingo.hardobjectives.temp::*} to {mcc.bingo.hardobjectives::*}
	delete {mcc.bingo.easyobjs::*}
	delete {mcc.bingo.medobjs::*}
	delete {mcc.bingo.hardobjs::*}
	loop 5 times:
		set {_rand} to random element out of {mcc.bingo.easyobjectives.temp::*}
		add {_rand} to {mcc.bingo.easyobjs::*}
		remove {_rand} from {mcc.bingo.easyobjectives.temp::*}
	loop 5 times:
		set {_rand} to random element out of {mcc.bingo.medobjectives.temp::*}
		add {_rand} to {mcc.bingo.medobjs::*}
		remove {_rand} from {mcc.bingo.medobjectives.temp::*}
	loop 5 times:
		set {_rand} to random element out of {mcc.bingo.hardobjectives.temp::*}
		add {_rand} to {mcc.bingo.hardobjs::*}
		remove {_rand} from {mcc.bingo.hardobjectives.temp::*}

command /registerbingoobjectves <text>:
	permission: op
	trigger:
		delete {mcc.bingo.%arg%objectives::*}
		loop items in inventory of player's target block:
			message loop-value
			add loop-value to {mcc.bingo.%arg%objectives::*}

command /addbingoobjectves <text>:
	permission: op
	trigger:
		#delete {mcc.bingo.%arg%objectives::*}
		loop items in inventory of player's target block:
			message loop-value
			add loop-value to {mcc.bingo.%arg%objectives::*}

on inventory click:
	if event-inventory is {mcc.bingo.board}:
		cancel event

function generatebingoobjective(diff:text):
	loop {mcc.bingo.%{_diff}%objs::*}:
		if loop-value is glass pane:
			if name of loop-value starts with "<light cyan>Completed by":
				remove loop-value from {mcc.bingo.%{_diff}%objs::*}
	set {_rand} to random element out of {mcc.bingo.%{_diff}%objectives.temp::*}
	add {_rand} to {mcc.bingo.%{_diff}%objs::*}
	if {_rand} is set:
		if name of {_rand} isn't set:
			if {_diff} is "easy":
				broadcast "<light cyan>[<gold>Bingo<light cyan>]<reset>New <lime>easy<reset> objective: pick up %{_rand}%"
			else if {_diff} is "med":
				broadcast "<light cyan>[<gold>Bingo<light cyan>]<reset>New <yellow>medium<reset> objective: pick up %{_rand}%"
			else if {_diff} is "hard":
				broadcast "<light cyan>[<gold>Bingo<light cyan>]<reset>New <red>hard<reset> objective: pick up %{_rand}%"
		else:
			if {_diff} is "easy":
				broadcast "<light cyan>[<gold>Bingo<light cyan>]<reset>New <lime>easy<reset> %name of {_rand}%"
			else if {_diff} is "med":
				broadcast "<light cyan>[<gold>Bingo<light cyan>]<reset>New <yellow>medium<reset> %name of {_rand}%"
			else if {_diff} is "hard":
				broadcast "<light cyan>[<gold>Bingo<light cyan>]<reset>New <red>hard<reset> %name of {_rand}%"
		remove {_rand} from {mcc.bingo.%{_diff}%objectives.temp::*}
	if {_diff} is "med":
		loop {mcc.bingo.%{_diff}%objs::*}:
			set slot (11+loop-counter) of {mcc.bingo.board} to loop-value
	if {_diff} is "easy":
		loop {mcc.bingo.%{_diff}%objs::*}:
			set slot (2+loop-counter) of {mcc.bingo.board} to loop-value
	if {_diff} is "hard":
		loop {mcc.bingo.%{_diff}%objs::*}:
			set slot (20+loop-counter) of {mcc.bingo.board} to loop-value

on pick up:
	"%player's world%" starts with "bingo"
	{mcc.bingo.inprogress} is true
	loop {mcc.bingo.easyobjs::*}:
		if type of loop-value is type of event-item:
			bingoscoreobjective(event-player,1 of event-item, "easy")
			wait 1 tick
			remove 1 of event-item from player
	loop {mcc.bingo.medobjs::*}:
		if type of loop-value is type of event-item:
			bingoscoreobjective(event-player, 1 of event-item, "med")
			wait 1 tick
			remove 1 of event-item from player
	loop {mcc.bingo.hardobjs::*}:
		if type of loop-value is type of event-item:
			bingoscoreobjective(event-player, 1 of event-item, "hard")
			wait 1 tick
			remove 1 of event-item from player

every second:
	if {mcc.bingonew.timeleft} is greater than 0:
		if {mcc.paused} is true:
			exit trigger
		loop 10 times:
			if {mcc.bingo.tpcooldown.%loop-number%} is greater than 0:
				subtract 1 from {mcc.bingo.tpcooldown.%loop-number%}
		subtract 1 from {mcc.bingonew.timeleft}
		# if {mcc.bingonew.timeleft} is equal to 900 or 650 or 400 or 150:
		# 	execute console command "/playmusic buildmart"
		if {mcc.bingonew.timeleft} is equal to 3:
			if {mcc.bingonew.stage} is equal to 0:
				loop all players:
					if {mcc.team.%loop-player%} is not equal to 0:
						execute console command "/boopboopboopbeep %loop-player%"
		else if {mcc.bingonew.timeleft} is equal to 0:
			if {mcc.bingonew.stage} is equal to 0:
				set {mcc.bingonew.timeleft} to 900 
				set {mcc.bingonew.stage} to 1
				loop blocks in radius 10 of {mcc.bingonew.locs::9}:
					if loop-block is barrier:
						set loop-block to air
			else if {mcc.bingonew.stage} is equal to 1:
				loop all players:
					if {mcc.team.%loop-player%} is not equal to 0:
						send title "<pink>Game over!" to loop-player for 3 seconds
				set {mcc.bingo.inprogress} to false
				set {mcc.bingonew.timeleft} to 30
				set {mcc.bingonew.stage} to 2
				execute console command "/mccstandings"					
			else if {mcc.bingonew.stage} is equal to 2:
				execute console command "/mccbreak"
				set {mcc.bingonew.timeleft} to -1
		else if {mcc.bingonew.timeleft} is equal to 600:
			if {mcc.bingonew.stage} is equal to 1:
				loop all players:
					add potion effect of speed 1 for 999 days to potion effects of loop-player
		else if {mcc.bingonew.timeleft} is equal to 300:
			if {mcc.bingonew.stage} is equal to 1:
				loop all players:
					add potion effect of haste 1 for 999 days to potion effects of loop-player
					add potion effect of speed 2 for 999 days to potion effects of loop-player

command /resetbingonew:
	permission: op
	trigger:
		execute console command "/mvdelete bingo_overworld"
		execute console command "/mvconfirm"
		execute console command "/mvdelete bingo_nether"
		execute console command "/mvconfirm"
		execute console command "/mvdelete bingo_end"
		execute console command "/mvconfirm"
		wait 1 second
		execute console command "/mvclone bingo_overworld_copy bingo_overworld"
		execute console command "/mvclone bingo_nether_copy bingo_nether"
		execute console command "/mvclone bingo_end_copy bingo_end"

command /teamtp <player>:
	trigger:
		if {mcc.currentevent} is not equal to "bingobutfast" or "bingoisland":
			message "<pink>You can only use this command during Bingo!"
			exit trigger
		if {mcc.team.%player%} is equal to 0:
			message "<pink>This command is only for MCC players!"
			exit trigger
		if {mcc.bingo.tpcooldown.%{mcc.team.%player%}%} is greater than 0:
			message "<pink>You must wait %time({mcc.bingo.tpcooldown.%{mcc.team.%player%}%})% <pink>to use this again!"	
			exit trigger
		if {mcc.team.%arg 1%} is not equal to {mcc.team.%player%}:
			message "<pink>%arg 1% <pink>is not on your team!"
			exit trigger
		teleport player to arg 1
		set {mcc.bingo.tpcooldown.%{mcc.team.%player%}%} to 180

on portal enter:
	"%player's world%" starts with "bingo"
	block at player is ender portal block
	cancel event
	if {mcc.bingonew.portalcooldown.%player%} is true:
		exit trigger
	set {mcc.bingonew.portalcooldown.%player%} to true	

	if block below event-location is blue ice:
		set {_ind} to 7
		set {_str} to "Snowy Taiga"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_overworld"
	else if block below event-location is huge red mushroom block:
		set {_ind} to 8
		set {_str} to "Dark Forest"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_overworld"
	else if block below event-location is andesite:
		set {_ind} to 10
		set {_str} to "Mountains"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_overworld"
	else if block below event-location is oak log:
		set {_ind} to 11
		set {_str} to "Forest"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_overworld"
	else if block below event-location is terracotta:
		set {_ind} to 12
		set {_str} to "Badlands"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_overworld"
	else if block below event-location is mossy cobblestone:
		set {_ind} to 13
		set {_str} to "Jungle"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_overworld"
	else if block below event-location is obsidian:
		set {_ind} to 14
		set {_str} to "Center End Island"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_end"
	else if block below event-location is endstone:
		set {_ind} to random integer between 15 and 17
		set {_str} to "Outer End Islands"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_end"
	else if block below event-location is purpur block:
		set {_ind} to 18
		set {_str} to "End City"
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_end"
	else if block below event-location is bedrock:
		set {_ind} to 9
		set {_str} to "Spawn"
	if {_ind} is set:
		#message {mcc.bingonew.locs::%{_ind}%}
		
		teleport player to {mcc.bingonew.locs::%{_ind}%}
		message "<lime>Teleported you to the %{_str}%<lime>! Coordinates: x: %round(x-coordinate of player)%, y: %round(y-coordinate of player)%, z: %round(z-coordinate of player)%"
		if {_ind} is 9:
			give player player's chestplate
			set player's chestplate to unbreakable elytra named "<gold>Bingo Elytra"
			set player's gamemode to adventure
		else:
			if player has unbreakable elytra named "<gold>Bingo Elytra":
				remove unbreakable elytra named "<gold>Bingo Elytra" from player
			set player's gamemode to survival
	wait 3 seconds
	set {mcc.bingonew.portalcooldown.%player%} to false

on gliding state change:
	if player's world is "bingo":
		wait 1 tick
		if gliding of player is on:
			push player forwards
	else:
		if "%player's world%" starts with "bingo":
			if player's chestplate is unbreakable elytra named "<gold>Bingo Elytra":
				set player's chestplate to air

on damage:
	if victim's world is "bingo":
		cancel event

on respawn:
	wait 1 tick
	if player's world is "bingo":
		give player player's chestplate
		set player's chestplate to unbreakable elytra named "<gold>Bingo Elytra"
		set player's gamemode to adventure
		execute console command "/effect give %player% night_vision infinite"
		#add potion effect of night vision 1 for 999 days to potion effects of player
		if {mcc.bingonew.timeleft} is less than 600:
			if {mcc.bingonew.stage} is equal to 1:
				add potion effect of speed 1 for 999 days to potion effects of player
		if {mcc.bingonew.timeleft} is less than 300:
			if {mcc.bingonew.stage} is equal to 1:
				add potion effect of haste 1 for 999 days to potion effects of player
				add potion effect of speed 2 for 999 days to potion effects of player
				

on portal enter:
	"%player's world%" starts with "bingo"
	block at player is nether portal block
	if {mcc.bingonew.portalcooldown.%player%} is true:
		exit trigger
	set {mcc.bingonew.portalcooldown.%player%} to true
	loop blocks in radius 4 of player:
		if loop-block is nether brick:
			set {_ind} to 1
			set {_str} to "Fortress" 
			
		if loop-block is netherrack:
			set {_ind} to 2
			set {_str} to "Nether Wastes" 
		if loop-block is warped nylium:
			set {_ind} to 3
			set {_str} to "Warped Forest" 
		if loop-block is crimson nylium:
			set {_ind} to 4
			set {_str} to "Crimson Forest" 
		if loop-block is basalt:
			set {_ind} to 5
			set {_str} to "Basalt Deltas" 
		if loop-block is soul soil:
			set {_ind} to 6
			set {_str} to "Soul Sand Valley" 
	if {_ind} is set:
		set world of {mcc.bingonew.locs::%{_ind}%} to world "bingo_nether"
		teleport player to {mcc.bingonew.locs::%{_ind}%}		
		message "<lime>Teleported you to the %{_str}%<lime>! Coordinates: x: %round(x-coordinate of player)%, y: %round(y-coordinate of player)%, z: %round(z-coordinate of player)%"
		if player's chestplate is unbreakable elytra named "<gold>Bingo Elytra":
			set player's chestplate to air
		set player's gamemode to survival
	wait 3 seconds
	set {mcc.bingonew.portalcooldown.%player%} to false
on teleport:
	player's world is "bingo"
	"%teleport cause%" is "end portal"
	cancel event

command /mccbingonewsetloc <number>:
	trigger:
		if command sender is not the console:
			if command sender is not "itsasquid2":
				message "<pink>You do not have permission to run this command!"
				exit trigger
		set {mcc.bingonew.locs::%arg 1%} to player's location

on place:
	"%event-world%" is equal to "bingo"
	distance between event-location and {mcc.bingonew.locs::9} is less than 130
	player's game mode is survival
	message "<pink>You cannot place blocks this close to spawn!" to event-player
	cancel event

on break:
	"%event-world%" is equal to "bingo"
	distance between event-location and {mcc.bingonew.locs::9} is less than 130
	player's game mode is survival
	if event-block is not birch log:
		if event-block is not oak log:
			if event-block is not stripped birch log:
				if event-block is not stripped oak log:
					if event-block is not birch leaves:
						if event-block is not oak leaves:
							message "<pink>You cannot break the trees this close to spawn!" to event-player
							cancel event

command /disablemobspawning:
	permission: op
	trigger:
		loop all worlds:
			if loop-value isn't world "bingo_end" or "bingo_nether" or "bingo_overworld":
				make player execute command "/mvgamerule doMobSpawning false %loop-value%"
		
#--------------------------tasks------------------------------------
on death:
	"%event-world%" starts with "bingo"
	victim is a player
	#broadcast damage type of damage source
	if {bingo.currentdeathcauses::*} contains damage type of damage source:
		set {_source} to damage source 
		if {mcc.bingo.easyobjs::*} contains {bingo.taskitem.deaths.%damage type of damage source%}:
			bingoscoreobjective(victim, {bingo.taskitem.deaths.%damage type of damage source%}, "easy")
			
		if {mcc.bingo.medobjs::*} contains {bingo.taskitem.deaths.%damage type of damage source%}:
			bingoscoreobjective(victim, {bingo.taskitem.deaths.%damage type of damage source%}, "med")

		if {mcc.bingo.hardobjs::*} contains {bingo.taskitem.deaths.%damage type of damage source%}:
			
			bingoscoreobjective(victim, {bingo.taskitem.deaths.%damage type of damage source%}, "hard")

command /registerbingodeathtask <damage type>:
	permission: op
	trigger:
		add arg to {bingo.currentdeathcauses::*}
		set {bingo.taskitem.deaths.%arg%} to player's tool
		message "registered %name of {bingo.taskitem.deaths.%arg%}% as the item for %arg%"

on tab complete of "/registerbingodeathtask":
	set tab completions for position 1 to all damage types

on rightclick:
	"%player's world%" starts with "bingo"
	if {bingo.rcontasks::*} contains type of player's tool:
		if {mcc.bingo.easyobjs::*} contains {bingo.taskitem.rcitem.%type of player's tool%}:
			bingoscoreobjective(player, {bingo.taskitem.rcitem.%type of player's tool%}, "easy")
		if {mcc.bingo.medobjs::*} contains {bingo.taskitem.rcitem.%type of player's tool%}:
			bingoscoreobjective(player, {bingo.taskitem.rcitem.%type of player's tool%}, "med")
		if {mcc.bingo.hardobjs::*} contains {bingo.taskitem.rcitem.%type of player's tool%}:
			bingoscoreobjective(player, {bingo.taskitem.rcitem.%type of player's tool%}, "hard")

command /registerbingorightclickwithtask:
	permission: op
	trigger:
		add type of player's offhand tool to {bingo.rcontasks::*}
		set {bingo.taskitem.rcitem.%type of player's offhand tool%} to player's tool
		message "registered %name of {bingo.taskitem.rcitem.%type of player's offhand tool%}% as the item for %type of player's offhand tool%"

on consume:
	"%player's world%" starts with "bingo"
	if {bingo.consumetasks::*} contains type of event-item:
		if {mcc.bingo.easyobjs::*} contains {bingo.taskitem.foods.%type of event-item%}:
			bingoscoreobjective(player, {bingo.taskitem.foods.%type of event-item%}, "easy")
			
		if {mcc.bingo.medobjs::*} contains {bingo.taskitem.foods.%type of event-item%}:
			bingoscoreobjective(player, {bingo.taskitem.foods.%type of event-item%}, "med")

		if {mcc.bingo.hardobjs::*} contains {bingo.taskitem.foods.%type of event-item%}:
			
			bingoscoreobjective(player, {bingo.taskitem.foods.%type of event-item%}, "hard")

command /registerbingoeattask:
	permission: op
	trigger:
		add type of player's offhand tool to {bingo.consumetasks::*} 
		set {bingo.taskitem.foods.%type of player's offhand tool%} to player's tool
		message "registered %name of {bingo.taskitem.foods.%type of player's offhand tool%}% as the item for %player's offhand tool%"
	
on break:
	"%player's world%" starts with "bingo"
	if {bingo.breaktasks::*} contains type of event-block:
		if {mcc.bingo.easyobjs::*} contains {bingo.taskitem.break.%type of event-block%}:
			bingoscoreobjective(player, {bingo.taskitem.break.%type of event-block%}, "easy")
			
		if {mcc.bingo.medobjs::*} contains {bingo.taskitem.break.%type of event-block%}:
			bingoscoreobjective(player, {bingo.taskitem.break.%type of event-block%}, "med")

		if {mcc.bingo.hardobjs::*} contains {bingo.taskitem.break.%type of event-block%}:
			
			bingoscoreobjective(player, {bingo.taskitem.break.%type of event-block%}, "hard")

command /registerbingobreaktask:
	permission: op
	trigger:
		add type of player's target block to {bingo.breaktasks::*} 
		set {bingo.taskitem.break.%type of player's target block%} to player's tool
		message "registered %name of {bingo.taskitem.break.%type of player's target block%}% as the item for %type of player's target block%"

